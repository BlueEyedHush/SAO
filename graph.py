from logging import getLogger

from enum import Enum

NodeState = Enum('NodeState', 'UNTOUCHED DEFENDED BURNING')

logger = getLogger("graph_printing")


class Graph(object):
    def __init__(self):
        self.nodes_number = 0
        self.nodes = dict()
        self.starting_nodes = list()
        super(Graph, self).__init__()

    def get_edges(self):
        edges = list()
        for node_id in self.nodes:
            for neighbor in self.nodes[node_id].neighbors:
                if (neighbor.id, node_id) not in edges:
                    edges.append((node_id, neighbor.id))
        return edges

    def get_burning_nodes(self):
        bnodes = set()
        for node_id in self.nodes:
            if self.nodes[node_id].state == NodeState.BURNING:
                bnodes.add(self.nodes[node_id])
        return bnodes

    def get_nodes(self):
        return self.nodes

    def get_starting_nodes(self):
        return self.starting_nodes

    @classmethod
    def from_file(cls, input_file):
        """ Generate graph from file format:
        n m
        1 4
        1 2
        2 3
        ...

        where:
            n - number of the vertices
            m - number of edges
        second line lists starting vertices
        the following lines determine edges
        this is exactly the format generated by the generate utility
        """

        new_instance = cls()
        with open(input_file, 'r') as f:
            new_instance.nodes_number, _ = map(int, f.readline().split())
            starting_nodes_ids = [int(s) for s in f.readline().split()]
            for node_id in xrange(new_instance.nodes_number):
                new_instance.nodes[node_id] = Node(node_id)
            for line in f:
                v1, v2 = map(int, line.split())
                new_instance.nodes[v1].add_neighbor(new_instance.nodes[v2])
            new_instance.starting_nodes = [new_instance.nodes[node_id] for node_id in starting_nodes_ids]
        return new_instance

    def print_graph(self):
        """ For the time being a dumb method to help with debugging """
        for node in self.nodes.values():
            logger.info("Node {}: {}".format(node.id, node.state))

    def reset_metadata(self):
        for v in self.nodes.values():
            v.reset_metadata()


class Node(object):
    def __init__(self, node_id, value=None):
        self.id = node_id
        self.neighbors = set()
        self.state = NodeState.UNTOUCHED
        self.value = value
        super(Node, self).__init__()

    def add_neighbor(self, node):
        self.neighbors.add(node)
        node.neighbors.add(self)

    def get_neighbors(self):
        return self.neighbors

    def print_node(self):
        """ Print the graph structure accessible from this node """
        logger.info("Node {}: {}".format(self.id, self.neighbors))

    def reset_metadata(self):
        self.state = NodeState.UNTOUCHED

    def __eq__(self, other):
        return self.id == other.id

    def __str__(self):
        return "Node({})".format(self.id)


# TODO: a lot of this methods could actually be common for graph and tree
class Tree(object):
    def __init__(self):
        self.nodes_number = 0
        self.nodes = dict()
        self.starting_nodes = list()
        super(Tree, self).__init__()

    def get_burning_nodes(self):
        bnodes = set()
        for node_id in self.nodes:
            if self.nodes[node_id].state == NodeState.BURNING:
                bnodes.add(self.nodes[node_id])
        return bnodes

    def get_edges(self):
        edges = list()
        for node_id in self.nodes:
            for neighbor in self.nodes[node_id].get_neighbors():
                if (neighbor.id, node_id) not in edges:
                    edges.append((node_id, neighbor.id))
        return edges

    def get_nodes(self):
        return self.nodes

    def get_starting_nodes(self):
        return self.starting_nodes

    @classmethod
    def from_file(cls, input_file):
        """ Generate graph from file format:
        n m
        1 4
        1 2
        2 3
        ...

        where:
            n - number of the vertices
            m - number of edges
        second line lists starting vertices
        the following lines determine edges
        this is exactly the format generated by the generate utility
        """

        new_instance = cls()
        with open(input_file, 'r') as f:
            new_instance.nodes_number, _ = map(int, f.readline().split())
            starting_nodes_ids = [int(s) for s in f.readline().split()]
            for node_id in xrange(new_instance.nodes_number):
                new_instance.nodes[node_id] = TreeNode(node_id)
            for line in f:
                v1, v2 = map(int, line.split())
                # new_instance.nodes[v1].add_neighbor(new_instance.nodes[v2])
                new_instance.nodes[v1].add_child(new_instance.nodes[v2])
            new_instance.starting_nodes = [new_instance.nodes[node_id] for node_id in starting_nodes_ids]
        return new_instance

    def reset_metadata(self):
        for v in self.nodes.values():
            v.reset_metadata()


class TreeNode(object):
    def __init__(self, node_id, value=None, parent=None):
        self.id = node_id
        self.left = None
        self.right = None
        self.parent = parent
        self.state = NodeState.UNTOUCHED
        self.value = value
        super(TreeNode, self).__init__()

    def add_child(self, node):
        if not self.left:
            self.add_left(node)
        elif not self.right:
            self.add_right(node)
        else:
            raise ValueError("Cannot add child. The node {} already has two children".format(self))

    def add_left(self, node):
        self.left = node
        node.parent = self

    def add_right(self, node):
        self.right = node
        node.parent = self

    def get_neighbors(self):
        ngbrs = set()
        if self.parent:
            ngbrs.add(self.parent)
        if self.left:
            ngbrs.add(self.left)
        if self.right:
            ngbrs.add(self.right)
        return ngbrs

    def reset_metadata(self):
        self.state = NodeState.UNTOUCHED

    def __eq__(self, other):
        return self.id == other.id

    def __str__(self):
        return "TreeNode({})".format(self.id)
