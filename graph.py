from logging import getLogger

from enum import Enum

NodeState = Enum('NodeState', 'UNTOUCHED DEFENDED BURNING')

logger = getLogger("graph_printing")

class Graph(object):
    def __init__(self):
        self.nodes_number = 0
        self.nodes = dict()
        self.starting_nodes = list()
        super(Graph, self).__init__()

    def get_edges(self):
        edges = list()
        for node_id in self.nodes:
            for neighbor in self.nodes[node_id].neighbors:
                if (neighbor.id, node_id) not in edges:
                    edges.append((node_id, neighbor.id))
        return edges

    def get_burning_nodes(self):
        bnodes = set()
        for node_id in self.nodes:
            if self.nodes[node_id].state == NodeState.BURNING:
                bnodes.add(self.nodes[node_id])
        return bnodes

    def get_nodes(self):
        return self.nodes

    def get_starting_nodes(self):
        return self.starting_nodes

    @classmethod
    def from_file(cls, input_file):
        """ Generate graph from file format:
        n m
        1 4
        1 2
        2 3
        ...

        where:
            n - number of the vertices
            m - number of edges
        second line lists starting vertices
        the following lines determine edges
        this is exactly the format generated by the generate utility
        """

        new_instance = cls()
        with open(input_file, 'r') as f:
            new_instance.nodes_number, _ = map(int, f.readline().split())
            new_instance.starting_nodes = [Node(int(s)) for s in f.readline().split()]
            for node_id in xrange(new_instance.nodes_number):
                new_instance.nodes[node_id] = Node(node_id)
            for line in f:
                v1, v2 = map(int, line.split())
                new_instance.nodes[v1].add_neighbor(new_instance.nodes[v2])
        return new_instance

    def print_graph(self):
        """ For the time being a dumb method to help with debugging """
        for node in self.nodes.values():
            logger.info("Node {}: {}".format(node.id, node.state))

    def reset_metadata(self):
        for v in self.nodes.values():
            v.reset_metadata()


class Node(object):
    def __init__(self, node_id, value=None):
        self.id = node_id
        self.neighbors = set()
        self.state = NodeState.UNTOUCHED
        self.value = value
        super(Node, self).__init__()

    def add_neighbor(self, node):
        self.neighbors.add(node)
        node.neighbors.add(self)

    def print_node(self):
        """ Print the graph structure accessible from this node """
        logger.info("Node {}: {}".format(self.id, self.neighbors))

    def reset_metadata(self):
        self.state = NodeState.UNTOUCHED

    def __eq__(self, other):
        return self.id == other.id


def graph_to_networkx(graph):
    import networkx as nx
    G = nx.Graph()
    G.add_nodes_from(graph.get_nodes())
    G.add_edges_from(graph.get_edges())
    return G
